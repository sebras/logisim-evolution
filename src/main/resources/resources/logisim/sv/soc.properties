#
# bus/SocBusAttributes.java
#
SocBusTraceSize = Spårstorlek:
SocBusTraceVisable = Spår synliga:
#
# bus/SocBusMenuProvider.java
#
insertTrans = Infoga en busstransaktion
SocBusMemMap = Visa minneskarta
SocBusTraceWindow = Visa spårning av busstransakation(er)
SocInsertTransWindowTitle = Infoga en transaktion på buss:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = Busspårningsfönster (dubbelklicka på ett spår för att ta bort det)
#
# data/SocBusInfo.java
#
SocBusNotConnected = Inte ansluten till en buss
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = Inga spår närvanade
SocMemMapWindowTitle = Minneskarta för buss:
SocMemoryMapOk = Stäng
SocMemoryMapTitle = Minneskarta (rött indikerar överlappande minnesområden):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = Inledare:
SocBusStateNoDataMax10chars = ingen data
SocBusStateSlave = Besvarare:
SocBusStateTraceIndex = Transkation nr.:
SocTransactionByteAccesNoSupport = Slav har inte stöd för byteåtkomster.
SocTransactionByteAccesNoSupportShort = Ingen byteåtkomst
SocTransactionHalfWordAccesNoSupport = Slav har inte stöd för halvordsåtkomster.
SocTransactionHalfWordAccesNoSupportShort = Ingen hårdvaruåtkomst
SocTransactionMisallignedAddress = Slav detekterar en feljusterad adress.
SocTransactionMisallignedAddressShort = Feljust. adr.
SocTransactionMultipleSlaveAnswers = Flera slavar svarade på en transaktion. Kontrollera minneskarta för dina slavar.
SocTransactionMultipleSlaveAnswersShort = Flera slavar
SocTransactionNoBusConnected = Mästarekomponenten är inte ansluten till någon Soc-buss. Anslut mästaren till en busskomponent.
SocTransactionNoBusConnectedShort = Ingen buss
SocTransactionNoneAtomicRW = En icke-atomiska läs-/skrivåtgärd är begärd. Detta är inte tillåtet.
SocTransactionNoneAtomicRWShort = Icke-atomisk LS
SocTransactionNoRespons = Ingen slavkomponent svarade på begäran. Kontrollera minnesadressen för begäran och minneskartan för ditt system.
SocTransactionNoResponsShort = Inget svar
SocTransactionNoSlavesAttached = Bussen som är ansluten till mästaren har inga slavar anslutna. Anslut några slavar till bussen.
SocTransactionNoSlavesAttachedShort = Inga slavar
SocTransactionReadOnlyAccessError = Slav har endast stöd för läsåtkomst på denna adress
SocTransactionReadOnlyAccessErrorShort = Endast läsning
SocTransactionRegisterDoesNotExist = Slav har inte stöd för någon åt6komst på denna adress
SocTransactionRegisterDoesNotExistShort = Ingen tillgång
SocTransactionSuccessfull = Inget fel har inträffat, transaktionen är framgångsrik.
SocTransactionSuccessfullShort = Framgång
SocTransactionUnknownError = Bisarrt, detta felmeddelande bör aldrig inträffa och representerar ett fel i logisim.
SocTransactionUnknownErrorShort = FEL!
SocTransactionWordAccesNoSupport = Slav har inte stöd för ordåtkomster.
SocTransactionWordAccesNoSupportShort = Ingen ordåkomst
SocTransactionWriteOnlyAccessError = Slav har inte stöd för läsåtgärder på denna adress.
SocTransactionWriteOnlyAccessErrorShort = Endast skrivning
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = Tom (inga slavar)
SocMemMapEndAddress = Slutadress:
SocMemMapSlaveName = Namn på komponent:
SocMemMapStartAddress = Startadress:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus =Välj en buss att ansluta till
SocBusSelectAttr = Ansluten buss
SocBusSelectAttrClick = Klicka för att välja
SocManagerNoBusses = Inga bussar tillgänglia, lägga till en SOC-buss till ditt schema
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = Läste framgångsrikt in elf-filen i minnet.\nStartpunkten för den körbara filen har satts i processorn.\n\nViktigt:\n   Då elf-filen inte har någon information om avbrottsverktorerna\n   måste du kontrollera dem själv!
SocUpMenuAsmWindow = Öppna assembler
SocUpMenuCpuAsmWindowTitle = assembler för CPU :
SocUpMenuCpuProgramWindowTitle = avassemblerare för CPU :
SocUpMenuCpuStateWindowTitle = processortillstånd för CPU :
SocUpMenuErrorReadingElfTitle = Fel vid läsning av elf-fil
SocUpMenuReadElf = Läs elf-fil
SocUpMenuSelectElfFile = Välj elf-fil att importera
SocUpMenuShowProgram = Visa inläst program
SocUpMenuShowState = Visa CPU-tillstånd
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = Stoppad
SocUpSimHaltBreak = Brytpunkt
SocUpSimHaltError = Fel
SocUpSimRunning = Kör
SocUpSimStateLabel = Simuleringstillstånd:
SocUpSimstateStart = Starta
SocUpSimstateStop = Pausa
SocUpUnknown = Okänt
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = Inte en 32- eller 64-bitars elf-fil
ElfHeaderEIDataError = Inte en fil kodad i omvänd eller rak byteordning
ElfHeaderIncorrectEISize = Storleken på EI-avsnittet är felaktigt
ElfHeaderIncorrectESize = Storleken på E-avsnittet är felaktigt
ElfHeaderIncorrectMagic = Filen innehåller inte det korrekta magiska elf-värdet; troligen inte en elf-fil
ElfHeaderNoErrors = Huvudet är korrekt
ElfHeaderReadingFileError = Fel vid läsning av filen
ElfHeaderUnknownArchitecture = Okänd arkitektur
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = Programhuvud ej hittat.
ProgHeaderReadError = Fel vid läsning av programhuvud.
ProgHeaderSizeError = Storlek för programhuvud stämmer inte.
ProgHeaderSuccess = Framgång
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = Hittade flera strängtabeller, stöds inte för tillfället.
ElfSectHeadMultiSymtabError = Hittade flera symboltabeller, stöds inte för tillfället.
ElfSectHeadNotFound = Avsnittshuvud hittades inte.
ElfSectHeadReadError = Fel vid läsning av avsnittshuvud.
ElfSectHeadSizeError = Storlek för avsnittshuvud stämmer inte.
ElfSectHeadStingIdxError = Indexfel för sträng.
ElfSectHeadStingNotFound = Avsnittsnamn hittas inte.
ElfSectHeadStingReadError = Fel vid läsning av strängtabell.
ElfSectHeadStingTypeError = Typfel för sträng.
ElfSectHeadSuccess = Framgång
ElfSymTableNotFound = Kunde inte hitta symboltabellen.
ElfSymTableReadError = Kunde inte läsa symboltabellen.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim har ännu inte stöd för 64-bitars elf-filer.
ProcReadElfArchError = Elf-filen är för en ”%s”-processor medan den borde vara för en ”%s”-processor.
ProcReadElfEndianMismatch = Byteordning stämmer inte, elf-filen är ”%s” medan processor begär ”%s”.
ProcReadElfErrorOpeningFile = Omöjligt att öppna elf-fil
ProcReadElfLoadableSectionNotFound = Inläsningsbart avsnitt hittades inte i elf-fil.
ProcReadElfLoadableSectionReadError = Fel vid inläsning av inläsningsbart avsnitt.
ProcReadElfLoadableSectionSizeError = Storlek stämmer inte för inläsningsbart avsnitt.
ProcReadElfLoadableSectionTooBig = Storleken för det inläsningsbara avsnittet är större än storleken som stöds av logisim.
ProcReadElfMemoryError = Ett fel har inträffat vid skrivning av ett inläsningsbart avsnitt till minnet.\nSäkerställ att du har en SOC-minneskomponent tillgänglig för minnesområdet:\n%s...%s
ProcReadElfNotExecutable = Elf-filen är inte körbart
ProcReadElfSuccess = Framgång
#
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = Assembler-filer (.asm,.S)
AsmPanAssemble = Assemblera koden (ALT-A)
AsmPanDocumentChangedSave = Det finns ändringar i ditt dokument, vill du spara dem?
AsmPanErrorCreateFile = Kani nte skara assemblerfilen.
AsmPanErrorReadingFile = Kan inte läsa filen
AsmPanNextError = Hoppa till nästa fel (CTRL-N)
AsmPanOpenFile = Läs en fil (CTRL-L)
AsmPanPreviousError = Hoppa till föregående fel (CTRL-P)
AsmPanReadAsmFile = Markera en fil att läsa
AsmPanRun = Kör koden (ALT-R)
AsmPanSaveAsmFile = Markera en fil att spara
AsmPanSaveFile = Spara filen (CTRL-S)
AsmPanSaveFileAs = Spara filen som
AsmPanSaveFirstBeforeOpen = Det finns ändringar i ditt dokument\nVill du spara dem innan du öppnar en ny fil?
AssemblerAssembleSuccess = Framgång!\nInga fel hittade i din kod.
AssemblerRunSuccess = Läste framgångsrikt in programmet till minnet.\nFör att köra programm, säkerställ att:\na) du aktiverat ticken\nb) att du satt CPU:n i körläge
AssemblerUnableToDownload = Kan inte lagra program i minnet,\nsäkerställ att du har tillräckligt med minne tillgängligt\npå korrekt minnespositioner.
RV32imAsmLineIndicator = Rad %d av %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = Ta bort brytpunkt
RV32imSetBreakpoint = Lägg till brytpunkt
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = Bussadress: 0x
SocTransInsAtomicRequest = Atomisk transaktion
SocTransInsByteAccess = Bytetransaktion
SocTransInsHalfWordAccess = Halvordstransaktion (2 byte)
SocTransInsInputData = Data att skriva: 0x
SocTransInsInsertTransaction = Infoga transaktionen på bussen
SocTransInsManual = Manuellt infogad
SocTransInsReadData = Returnera data:
SocTransInsReadRequest = Läsbegäran på buss
SocTransInsTransResultTitle = Resultat av den infogade transaktionen:
SocTransInsWordAccess = Ordtransaktion (4 byte)
SocTransInsWriteRequest = Skrivbeäran på buss
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = Assembler:
Rv32imBinInstruction = Opkod:
Rv32imEmptyTrace = Inga körningsspår tillgängliga
Rv32imExecutionTrace = Exekveringsspårk (senast kört på toppen):
Rv32imRegisterFile = Registermapp:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = Simuleringskontroll
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = Rensa tangentbord
JtagUartKeybAvailable = Tangentbordsdata tillgänglig
JtagUartKeybData = Tangentbordsdata
JtagUartKeybReadEnable = Tangentbordsläsning aktiverad
JtagUartTtyClear = TTY rensa
JtagUartTtyData = TTY data
JtagUartTtyWrite = TTY skrivdata
SocJtagUartComponent = JTAG UART-komponent
#
# jtaguart/JtagUartAttributes.java
#
JtagSize1024 = 1k
JtagSize128 = 128
JtagSize16 = 16
JtagSize16384 = 16k
JtagSize2048 = 2k
JtagSize256 = 256
JtagSize32 = 32
JtagSize32768 = 32k
JtagSize4096 = 4k
JtagSize512 = 512
JtagSize64 = 64
JtagSize8 = 8
JtagSize8192 = 8k
JtagUartReadIrqThreshold = Läs-IRQ tröskel
JtagUartWriteIrqThreshold = Skriv-IRQ tröskel
UartJtagREADFifoSize = Läs-FIFO storlek:
UartJtagWriteFifoSize = Skriv-FIFO storlek:
#
# memory/SocMemory.java
#
SocMemBase = Bas:
SocMemoryComponent = Minnessimulator
SocMemSizeStr = Storlek:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = Byteadressbredd:
SocMemStartAddress = Startadress:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Nios2s-simulator
Nios2Dataa = Data A
Nios2Datab = Data B
Nios2Done = Klar
Nios2N = N
Nios2ReadRa = Läs Ra
Nios2ReadRb = Läs Rb
Nios2Result = Resultat
Nios2Start = Starta
Nios2WriteRc = Skriv Rc
Rv32imClockInput = Klockingång
Rv32imIrqInput = IRQ-ingång %s
Rv32imResetInput = Återställningsingång
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = Brytvektor
rv32ExceptionVector = Avbrottsvektor
rv32imIrqWidth = Antal IRQ-signaler
rv32ResetVector = Återställningsvektor
rv32StateVisable = Synligt tillstånd:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = Förväntade fyra argument
Nios2DonePinError = Klar-pinne inte definierad eller kan inte fortsätta i feltillstånd.\nKontrollera Klar-pinnen.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = Fel vid läsning från minnessystem:
LoadStoreErrorInWriteTransaction = Fel vid lagring till minnessystem:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = Förväntade ett omedelbart värde
AssemblerExpectedNoArguments = Förväntade inga argument
AssemblerExpectedOneArgument = Förväntade ett argument
AssemblerExpectedTwoArguments = Förväntade två argument
AssemblerExpectedZeroOrOneArgument = Förväntade inga eller ett argument
AssemblerImmediateOutOfRange = Det omedelbara värde är utanför intervall
AssemblerUnknownRegister = Okänt register
Nios2AssemblerExpectedBracketedRegister = Förväntade ett register i klammer, t.ex. (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = Förväntade ett omedelbart indexerat register, t.ex. 5(r1)
Nios2CannotUseControlRegister = Kan inte använda ett kontrollregister i detta sammanhang
Nios2CannotUseCustomRegister = Kan inte använda ett anpassat register i detta sammanhang
Nios2ExpectedControlRegister = Förväntade ett kontrollregister (t.ex. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = Förväntade tre argument
AssemblerExpextedImmediateOrLabel = Förväntade ett omedelbart värde eller en etikett
#
# nios2/Nios2State.java
#
Nios2Bstatus = bstatus
Nios2Estatus = estatus
Nios2Status = status
RV32imBreakPointReached = Exekvering är pausad på grund av att en brytpunkt är satt på den aktuella instruktionen.
RV32imFetchExecutionError = Fel vid exekvering av hämtad instruktion
RV32imFetchInvalidInstruction = Ogiltig instruktion hämtad
RV32imFetchInvInstrAsm = Ogiltig instruktion!
RV32imFetchTransaction = -> Transaktionsfel vid hämtning.
Rv32imProgramCounter = ir:
SocHiddenForFasterSimulation = Innehåll göms för snabbare simulering
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = Förväntade ett register
#
# pio/PioAttributes.java
#
SicPioIrqType = Irq-typ:
SocPioAnyEdge = Any edge
SocPioBidir = Bidirektionella (tri-state) portar
SocPioCaptureEdge = Infångningstyp:
SocPioDirection = Riktning:
SocPioFallingEdge = Fallande flank
SocPioGenIRQ = IRQ-aktiverad:
SocPioInout = Både ingångs- och utgångsportar
SocPioInputCaptureBit = Fånga in bitrensning:
SocPioInputOnly = Endas ingångsportar
SocPioInputsSyncCapture = Synk. infångning:
SocPioIrQEdge = Flank
SocPioIrqLevel = Nivå
SocPioOutputIndividualBits = Utångsbit satt/rensad:
SocPioOutputOnly = Endast utgångsportar
SocPioOutputResetValue = Återställningsvärde för utgång:
SocPioRisingEdge = Stigande flank
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = Kunde inte skapa huvud och/eller c-fil!
ExportC = Exportera C-mallar
PioMenuBidirFunctionsRemark = /* Med följande funktioner kan de bidirektionella registret sättas eller läsas ut\n en etta indikerar att respektive bit är en utgång, en 0 indikerar att det är en ingång\n Notera: endas de lägre %s bitarna används.\n */
PioMenuCaptureAll = rensa alla bitnar i infångningsregistret oberoende av värdet på parametern "value"
PioMenuCaptureAny = åtminstone en ändring från 0 till 1 eller från 1 till 0
PioMenuCaptureBit = rensa bitarna i infångningsregistret som är 1 i parametern "value"
PioMenuCaptureFalling = åtminstone en ändring från 1 till 0
PioMenuCaptureRising = åtminstone en ändring från 0 till 1
PioMenuEdgeCaptureRemark = /* Med följande funktioner kan flankfångningsregistret rensas eller läsas ut\n om flankregistret läses ut indikerar en etta på en position att\n respektive ingånga har haft %s,\n annars har respektive ingång inte ändrats.\n \n Skrivning till detta register kommer att %s.\n Notera: endast de lägre %s bitarna används.*\n */
PioMenuInputDataFunctionRemark = /* Med följande funktion kan ingångsvärdena för PIO:n\n läsas ut.\n Denna funktion returnerar respektive värden\n Notera: endast de lägre %s bitarna är giltiga\n */
PioMenuIrqEdge = motsvarande bit i infångningsregistret
PioMenuIrqLevel = motsvarande ingång
PioMenuMaskFunctionsRemark = /* Med följande funktoin kan avbrottsmaskregistret sättas eller läsas ut.\n En etta på en specifik plats indikerar att ett avbrott kommer att genereras\n om %s är lika med 1.\n Notera: endast de lägre %s bitarna används.\n */
PioMenuOutClearRemark = /* Med följande funktion kommer bitarna som är 1 i parametern "value" att tvinga\n motsvarande utång till 0\n Notera: endast de lägre %s bitarna används.\n */
PioMenuOutputDataFunctionRemark = /* Med följande funktion kommer utgångsvärdena för PIO:n att kunna\n * sättas.\n * Denna funktion tar det nya utgångsvärdet som parameterns "value"\n * Notera: endast de lägre %s bitarna i den tillhandahållna parametern "value" är giltiga\n */
PioMenuOutSetRemark = /* Med följande funktion kommer bitar som är 1 i parametern "value" att tvinga\n * motsvarande utgång till 1\n * Notera: endast de lägre %s bitarna används.\n */
SelectDirectoryToStoreC = Sätt katalogen att spara C-mallarna i
SuccesCreatingHeaderAndCFile = Skapade framgångsrikt filerna:\n%s\noch\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = Bidir bit %s
SocPioBidirs = Bidirektionell pinne
SocPioComponent = Parallell ingångs-/utgångsexpanderare
SocPioInputPinx = Ingångsbit %s
SocPioInputs = Ingångspinnar
SocPioIrqOutput = Irq-utgång
SocPioOutputPinx = Utgångsbit %s
SocPioOutputs = Utgångspinnar
SocPioResetInput = Återställningsingång
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Risc V IM-simulator
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = Förväntade en eller två argument
Rv32imAssemblerExpectedTwoOrThreeArguments = Förväntade två eller tre argument
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = Miljömässiga anrop och brytpunkter är för närvarande inte implementerade
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = FEL!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = Förväntade ett register i klammer, t.ex. (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = Förväntade ett omedelbart indexerat register, t.ex. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = Assembleropkod stöds ej
Rv32imMOINotImplmented = Minnesordningsinstruktionerna är för närvarande inte implemented 
#
# Soc.java
#
SocBusComponent = SOC-buss-simulator
socLibrary = System On Chip-komponenter
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = Okänd opkod
UnknownInstruction = Okänd instruktion
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = Förutsätter att den lägsta adressen med en instruktion är startpunkten.\nFör att säkerställa att din CPU börjar köra på rätt adress\nlägg till en etikett kallad ”_start” på platsen\ndär din CPU ska börjar köra programmet.
AssemblerCannotUseInsideMacro = Denna konstruktion kan inte användas inuti en makrodefinition
AssemblerEndOfMacroNotFound = Kunde inte hitta slutet på makrodefinitionen
AssemblerExpectedMacroName = Förväntade ett namn på makrot
AssemblerExpectedMacroNrOfParameters = Förväntade ett antal makroparametrar
AssemblerExpectingLabelIdentifier = Förväntade en etikett
AssemblerMissingLabelBefore = För denna operator bör vara en etikett
AssemblerNoExecutableSection = Inga instruktioner hittade som kan köras.
AssemblerReguiresNumberAfterMath = Efter en matematikoperation bör ett nummer följa
AssemblerUnknowCharacter = Okänt tecken
AssemblerWrongClosingBracket = Denna avslutande klammer stöds inte
AssemblerWrongOpeningBracket = Denna inledande klammer stöds inte
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = Kan inte avgära adress för denna etikett
AssemblerCouldNotFindValueForDefine = Kan inte hitta en definition för denna parameter
AssemblerDivZero = Division med noll-fel
AssemblerExpectedImmediateValueAfterMath = Förväntade ett omedelbart värde efter en matematikoperation
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = Etikettnamn måste vara unika, hittade flera definitioner av denna etikett
AssemblerDuplicatedName = Kan inte använda samma namn för en .equ och en etikett
AssemblerDuplicatedSectionError = Avsnittsnamn måste vara unika, hittade flera avsnitt med detta namn
AssemblerExpectedLabel = Förväntade en etikett
AssemblerExpectedLabelAndNumber = Förväntade en etikett följt av ett omedelbart värde
AssemblerExpectedParameter = Förväntade en parameter på denna position
AssemblerExpectingNumber = Förväntade ett tal
AssemblerExpectingPositiveNumber = Förväntade ett positivt tal
AssemblerExpectingSectionName = Förväntade ett namn på detta avsnitt
AssemblerExpectingString = Förväntade en sträng
AssemblerMacroIncorrectNumberOfParameters = Felaktigt antal makroparametrar angivna
AssemblerOverlappingSections = Detta avsnitt överlappar med ett annat avsnitt
AssemblerUnknownIdentifier = Denna identifierare är okänd
AssemblerUnknownLabel = Denna etikett har inte definierats, och kan därför inte användas
AssemblerUnsupportedAssemblerInstruction = Denna assemblerinstruktion är inte känd
AssemblerValueOutOfRange = Värde är utanför intervall
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = Makron anropar varandra vilket förorsakar en dödlåsningssituation
AssemblerMacroCannotUseRecurency = Makro anropar sig själv vilket förorsakar en dödlåsningssituation
AssemblerMacroParameterNotDefined = Denna makroparameter är inte definieras, kontrollera antalet parametrar i din makrodefintion
#
# vga/SocVgaShape.java
#
SocVgaComponent = VGA-skärm
#
# vga/VgaAttributes.java
#
VgaBufferAddress = Adress för bildpunktsbuffert:
VgaInitialDisplayMode = Inledande läge:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = Programvaru-1024x768:
VgaSoft160x120 = Programvaru-160x120:
VgaSoft320x240 = Programvaru-320x240:
VgaSoft640x480 = Programvaru-640x480:
VgaSoft800x600 = Programvaru-800x600:
VgaStartAddress = Basadress:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* Med följande funktioner kan vga-läget manipuleras.\n Läsning av vga-läget returnerar de lägen som stöds (se ovanstående define för möjliga lägen)\n Skrivning av ett läge som stöds kommer att ändra visningsläget för VGA-skärmen\n */


